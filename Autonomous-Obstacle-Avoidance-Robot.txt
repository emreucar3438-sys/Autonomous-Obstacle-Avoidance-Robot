
/*
 * Autonomous Obstacle Avoidance Robot - R&D Project
 * Filter Stack: Median Filter + Exponential Moving Average (EMA)
 */

#include <NewPing.h>
#include <Servo.h>

// --- Pin Definitions ---
#define TRIGGER_PIN 12
#define ECHO_PIN    11
#define MAX_DISTANCE 200

// Motor Driver Pins (L298N)
const int leftForward  = 5;
const int leftBackward = 6;
const int rightForward = 7;
const int rightBackward = 8;
const int servoPin     = 10;

// --- Signal Processing Parameters ---
#define FILTER_SIZE 5
#define ALPHA 0.3f // EMA smoothing factor

int distanceHistory[FILTER_SIZE];
int historyIndex = 0;
float filteredDistance = 0;

NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);
Servo headServo;

void setup() {
  pinMode(leftForward, OUTPUT);
  pinMode(leftBackward, OUTPUT);
  pinMode(rightForward, OUTPUT);
  pinMode(rightBackward, OUTPUT);
  
  headServo.attach(servoPin);
  headServo.write(90); // Initial position
  
  delay(2000); // Startup delay
}

void loop() {
  // 1. Data Acquisition & Circular Buffer Update
  int rawDistance = sonar.ping_cm();
  
  // Handle out of range values
  if (rawDistance == 0) rawDistance = MAX_DISTANCE;
  
  distanceHistory[historyIndex] = rawDistance;
  historyIndex = (historyIndex + 1) % FILTER_SIZE;
  
  // 2. Median Filtering: Eliminates sensor spikes (salt-and-pepper noise)
  int medianValue = calculateMedian(distanceHistory, FILTER_SIZE);
  
  // 3. EMA Filtering: Provides temporal smoothing for fluid motion
  // Formula: EMA = (α * new_sample) + ((1 - α) * previous_EMA)
  filteredDistance = (ALPHA * medianValue) + ((1.0 - ALPHA) * filteredDistance);
  
  // 4. Decision Logic
  if (filteredDistance > 0 && filteredDistance < 30) {
    avoidObstacle();
  } else {
    moveForward();
  }
  
  delay(30); // Sampling period
}

// Median calculation using Bubble Sort (Efficient for small N)
int calculateMedian(int arr[], int n) {
  int temp[n];
  for (int i = 0; i < n; i++) temp[i] = arr[i];

  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (temp[j] > temp[j + 1]) {
        int t = temp[j];
        temp[j] = temp[j + 1];
        temp[j + 1] = t;
      }
    }
  }
  return temp[n / 2];
}



void avoidObstacle() {
  stopMotors();
  delay(200);
  moveBackward();
  delay(400);
  stopMotors();
  
  // Environment Scanning
  headServo.write(20); // Scan Right
  delay(500);
  int rightDistance = sonar.ping_cm();
  if (rightDistance == 0) rightDistance = MAX_DISTANCE;
  
  headServo.write(160); // Scan Left
  delay(700);
  int leftDistance = sonar.ping_cm();
  if (leftDistance == 0) leftDistance = MAX_DISTANCE;
  
  headServo.write(90); // Reset position
  delay(400);
  
  // Pathfinding decision
  if (rightDistance >= leftDistance) {
    turnRight();
  } else {
    turnLeft();
  }
  delay(500); // Turning duration
  stopMotors();
}

// --- Primitive Motor Control Functions ---
void moveForward() {
  digitalWrite(leftForward, HIGH); digitalWrite(rightForward, HIGH);
  digitalWrite(leftBackward, LOW); digitalWrite(rightBackward, LOW);
}

void moveBackward() {
  digitalWrite(leftForward, LOW);  digitalWrite(rightForward, LOW);
  digitalWrite(leftBackward, HIGH); digitalWrite(rightBackward, HIGH);
}

void turnRight() {
  digitalWrite(leftForward, HIGH); digitalWrite(rightBackward, HIGH);
  digitalWrite(leftBackward, LOW);  digitalWrite(rightForward, LOW);
}

void turnLeft() {
  digitalWrite(leftForward, LOW);   digitalWrite(rightBackward, LOW);
  digitalWrite(leftBackward, HIGH);  digitalWrite(rightForward, HIGH);
}

void stopMotors() {
  digitalWrite(leftForward, LOW); digitalWrite(rightForward, LOW);
  digitalWrite(leftBackward, LOW); digitalWrite(rightBackward, LOW);
}
